

<body onLoad="init();" style="background:black">
  <canvas id="canvas">
  </canvas>
</body>

<script>
  function init() {
    var numberofcircles = 20;
    var circles = [];
    var canvas = document.getElementById('canvas');
    var context = canvas.getContext('2d');

    var size = 6;
    var width = window.innerWidth - 10;
    var height = window.innerHeight - 10;

    function Circle(speed, size, xPos, yPos) {
      this.speed = speed;
      this.width = size;
      this.xPos = xPos;
      this.yPos = yPos;
      this.speedX=speed;
      this.speedY=speed;
      this.color='#'+(Math.random()*0xFFFFFF<<0).toString(16);

      this.counter = 0;

      var signHelper = Math.floor(Math.random() * 2);

      if (signHelper == 1) {
          this.sign = -1;
      } else {
          this.sign = 1;
      }
    }

    Circle.prototype.update = function () {
      context.beginPath();
      context.fillStyle=this.color;
      context.arc(this.xPos,this.yPos,this.width,0,Math.PI*2,true);
      context.closePath();
      context.fill();

      // Boundary Logic
      if(this.xPos<0 || this.xPos>width) this.speedX=-this.speedX;
      if(this.yPos<0 || this.yPos>height) this.speedY=-this.speedY;

      this.xPos+= this.sign * this.speedX;
      this.yPos+= this.sign * this.speedY;
    };

    function loadCircles() {
      canvas.width = width;
      canvas.height = height;

      for (var i = 0; i < numberofcircles; i++) {
        var x=Math.floor(Math.random() * width) + 1;
        var y=Math.floor(Math.random() * height) + 1;
        var speed = .2 + Math.random() * 3;

        var circle = new Circle(speed, size, x, y);
        circles.push(circle);
      }

      draw();
    }

    function checkRelationships(circles) {
      var i = 0;

      for (i = 0; i < circles.length; i++) {
        var j = 0;
        var currentCircle = circles[i];

        x1 = currentCircle.xPos;
        y1 = currentCircle.yPos;

        for (j = 0; j < circles.length; j++) {
          if(j!=i) {
            var neighbourCircle = circles[j];

            x2 = neighbourCircle.xPos;
            y2 = neighbourCircle.yPos;

            isIntimate(x1, y1, x2, y2);
          }
        }
      }
    }

    function isIntimate(x1, y1, x2, y2) {
      var strength = 200;
      if ((Math.abs(x1 - x2) <= strength) && (Math.abs(y1 - y2) <= strength)) {
        console.log('first dot coords - x: ' + x1 + ', y: ' + y1);
        console.log('second dot coords - x: ' + x2 + ', y: ' + y2);
        console.log('close!');

        context.moveTo(x1,y1);
        context.strokeStyle="#ffffff";
        context.lineTo(x2,y2);
        context.stroke();
      }
    }

    function draw() {
      context.clearRect(0,0,width,height);

      for (var i = 0; i < circles.length; i++) {
          var myCircle = circles[i];
          myCircle.update();
      }
      checkRelationships(circles);
      requestAnimationFrame(draw);
    }


    loadCircles();
  }
</script>
